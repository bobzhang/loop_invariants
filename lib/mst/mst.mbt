// ============================================================================
// MINIMUM SPANNING TREE - Kruskal's and Prim's Algorithms
// ============================================================================
//
// A Minimum Spanning Tree (MST) connects all vertices with minimum total edge
// weight. For a graph with n vertices, MST has exactly n-1 edges.
//
// KRUSKAL'S ALGORITHM:
// 1. Sort edges by weight
// 2. For each edge in order, add to MST if it doesn't create a cycle
// 3. Use Union-Find to detect cycles efficiently
//
// PRIM'S ALGORITHM:
// 1. Start from any vertex, grow MST one vertex at a time
// 2. Always add the minimum weight edge connecting MST to non-MST vertex
// 3. Use priority queue for efficiency
//
// KEY INSIGHT (Cut Property):
// For any cut of the graph, the minimum weight edge crossing the cut
// is in some MST. Both algorithms exploit this property.
//
// INVARIANTS:
// 1. Selected edges form a forest (no cycles)
// 2. At each step, edges selected are part of some MST
// 3. After n-1 edges, we have a spanning tree
//
// TIME COMPLEXITY: O(E log E) for both algorithms
// SPACE COMPLEXITY: O(V + E)

///|
priv struct Edge {
  u : Int
  v : Int
  weight : Int64
}

///|
priv struct MST {
  n : Int
  edges : Array[Edge]
}

///|
fn MST::new(n : Int) -> MST {
  { n, edges: [] }
}

///|
fn MST::add_edge(self : MST, u : Int, v : Int, weight : Int64) -> Unit {
  self.edges.push({ u, v, weight })
}

///|
/// Union-Find for cycle detection
priv struct UF {
  parent : Array[Int]
  rank : Array[Int]
}

///|
fn UF::new(n : Int) -> UF {
  let parent = Array::make(n, 0)
  let rank = Array::make(n, 0)
  for i = 0; i < n; i = i + 1 {
    parent[i] = i
  } where {
    invariant: i >= 0 && i <= n,
    reasoning: "I: parent initialized but not assigned. M: Set parent[i] = i to make each node its own representative. T: After i = n, all vertices are separate sets.",
  }
  { parent, rank }
}

///|
fn UF::find(self : UF, x : Int) -> Int {
  if self.parent[x] != x {
    self.parent[x] = self.find(self.parent[x])
  }
  self.parent[x]
}

///|
fn UF::union(self : UF, x : Int, y : Int) -> Bool {
  let rx = self.find(x)
  let ry = self.find(y)
  if rx == ry {
    return false
  }
  if self.rank[rx] < self.rank[ry] {
    self.parent[rx] = ry
  } else if self.rank[rx] > self.rank[ry] {
    self.parent[ry] = rx
  } else {
    self.parent[ry] = rx
    self.rank[rx] = self.rank[rx] + 1
  }
  true
}

///|
/// Kruskal's algorithm
fn MST::kruskal(self : MST) -> (Array[Edge], Int64) {
  if self.n <= 1 {
    return ([], 0L)
  }

  // Sort edges by weight
  let sorted_edges = self.edges.copy()
  sorted_edges.sort_by(fn(a, b) {
    if a.weight < b.weight {
      -1
    } else if a.weight > b.weight {
      1
    } else {
      0
    }
  })
  let uf = UF::new(self.n)
  let mst_edges : Array[Edge] = []
  let mut total_weight = 0L
  for i = 0; i < sorted_edges.length(); i = i + 1 {
    if mst_edges.length() == self.n - 1 {
      break
    }
    let edge = sorted_edges[i]
    if uf.union(edge.u, edge.v) {
      mst_edges.push(edge)
      total_weight = total_weight + edge.weight
    }
  } where {
    invariant: i >= 0 && i <= sorted_edges.length(),
    reasoning: "I: No edges selected, empty forest. M: Consider edges in weight order. If edge (u,v) connects different components (find(u) != find(v)), add to MST and union components. This maintains forest property and by cut property, edge is in some MST. T: After n-1 edges or all edges considered, MST complete.",
  }
  (mst_edges, total_weight)
}

///|
/// Check if graph is connected
fn MST::is_connected(self : MST) -> Bool {
  if self.n <= 1 {
    return true
  }
  let (edges, _) = self.kruskal()
  edges.length() == self.n - 1
}

///|
/// Get MST weight
fn MST::get_mst_weight(self : MST) -> Int64? {
  if self.n <= 1 {
    return Some(0L)
  }
  let (edges, weight) = self.kruskal()
  if edges.length() == self.n - 1 {
    Some(weight)
  } else {
    None
  }
}

// ============================================================================
// PRIM'S ALGORITHM (using simple O(V^2) approach)
// ============================================================================

///|
priv struct PrimMST {
  n : Int
  adj : Array[Array[(Int, Int64)]] // (neighbor, weight)
}

///|
fn PrimMST::new(n : Int) -> PrimMST {
  let adj = Array::make(n, [])
  for i = 0; i < n; i = i + 1 {
    adj[i] = []
  } where {
    invariant: i >= 0 && i <= n,
    reasoning: "I: adj has length n. M: Assign a fresh empty list at index i. T: After i = n, all vertices have empty adjacency lists.",
  }
  { n, adj }
}

///|
fn PrimMST::add_edge(self : PrimMST, u : Int, v : Int, weight : Int64) -> Unit {
  self.adj[u].push((v, weight))
  self.adj[v].push((u, weight))
}

///|
const PRIM_INF : Int64 = 9223372036854775807L

///|
fn PrimMST::compute(self : PrimMST) -> Int64? {
  if self.n <= 1 {
    return Some(0L)
  }
  let in_mst = Array::make(self.n, false)
  let min_edge = Array::make(self.n, PRIM_INF)
  min_edge[0] = 0L
  let mut total_weight = 0L
  let mut edges_added = 0
  for iter = 0; iter < self.n; iter = iter + 1 {
    // Find minimum edge to non-MST vertex
    let mut u = -1
    let mut min_w = PRIM_INF
    for i = 0; i < self.n; i = i + 1 {
      if not(in_mst[i]) && min_edge[i] < min_w {
        min_w = min_edge[i]
        u = i
      }
    } where {
      invariant: i >= 0 && i <= self.n,
      reasoning: "I: min_w is the best candidate among examined vertices. M: Scan vertices not in MST to find minimum min_edge. T: After i = n, u is the argmin of min_edge over non-MST vertices (or stays -1 if none).",
    }
    if u < 0 || min_w == PRIM_INF {
      break // No more reachable vertices
    }
    in_mst[u] = true
    total_weight = total_weight + min_w
    if iter > 0 {
      edges_added = edges_added + 1
    }

    // Update min_edge for neighbors
    for i = 0; i < self.adj[u].length(); i = i + 1 {
      let (v, w) = self.adj[u][i]
      if not(in_mst[v]) && w < min_edge[v] {
        min_edge[v] = w
      }
    } where {
      invariant: i >= 0 && i <= self.adj[u].length() && in_mst[u],
      reasoning: "I: u is newly added to MST. M: For each neighbor v, relax min_edge[v] with edge (u,v). T: After i = deg(u), min_edge records the cheapest edge from MST to each vertex.",
    }
  } where {
    invariant: iter >= 0 && iter <= self.n,
    reasoning: "I: Start vertex 0 has min_edge=0. M: Each iteration adds the non-MST vertex with minimum connecting edge. Update min_edge for its neighbors. By cut property, this edge is in some MST. T: After n iterations or no reachable vertex, MST complete.",
  }
  if edges_added == self.n - 1 {
    Some(total_weight)
  } else {
    None
  }
}

// ============================================================================
// TESTS
// ============================================================================

///|
test "mst kruskal basic" {
  let mst = MST::new(4)
  mst.add_edge(0, 1, 1L)
  mst.add_edge(1, 2, 2L)
  mst.add_edge(2, 3, 3L)
  mst.add_edge(0, 3, 4L)
  mst.add_edge(1, 3, 5L)
  let (edges, weight) = mst.kruskal()
  inspect(edges.length(), content="3")
  inspect(weight, content="6") // 1 + 2 + 3
}

///|
test "mst kruskal triangle" {
  let mst = MST::new(3)
  mst.add_edge(0, 1, 1L)
  mst.add_edge(1, 2, 2L)
  mst.add_edge(0, 2, 3L)
  inspect(mst.get_mst_weight(), content="Some(3)") // 1 + 2
}

///|
test "mst disconnected" {
  let mst = MST::new(4)
  mst.add_edge(0, 1, 1L)
  mst.add_edge(2, 3, 2L)
  inspect(mst.is_connected(), content="false")
  inspect(mst.get_mst_weight(), content="None")
}

///|
test "mst single vertex" {
  let mst = MST::new(1)
  inspect(mst.get_mst_weight(), content="Some(0)")
}

///|
test "prim basic" {
  let prim = PrimMST::new(4)
  prim.add_edge(0, 1, 1L)
  prim.add_edge(1, 2, 2L)
  prim.add_edge(2, 3, 3L)
  prim.add_edge(0, 3, 4L)
  inspect(prim.compute(), content="Some(6)")
}

///|
test "mst same weights" {
  let mst = MST::new(3)
  mst.add_edge(0, 1, 1L)
  mst.add_edge(1, 2, 1L)
  mst.add_edge(0, 2, 1L)
  inspect(mst.get_mst_weight(), content="Some(2)")
}
